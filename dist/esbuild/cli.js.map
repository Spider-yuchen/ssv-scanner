{
  "version": 3,
  "sources": ["../../src/cli-shared.ts", "../../src/commands/Command.ts", "../../src/lib/NonceScanner/NonceScanner.ts", "../../src/lib/web3.provider.ts", "../../src/lib/BaseScanner.ts", "../../src/commands/NonceCommand.ts", "../../src/lib/ClusterScanner/ClusterScanner.ts", "../../src/commands/ClusterCommand.ts", "../../src/cli.ts"],
  "sourcesContent": ["import figlet from 'figlet';\nimport pkg from '../package.json';\nimport { ArgumentParser } from 'argparse';\n\nimport { NonceCommand } from './commands/NonceCommand';\nimport { ClusterCommand } from './commands/ClusterCommand';\n// import { SSVScannerCommand } from './commands/SSVScannerCommand';\n\nconst FigletMessage = async (message: string) => {\n  return new Promise(resolve => {\n    figlet(message, (error: any, output?: string) => {\n      if (error) {\n        return resolve('');\n      }\n      resolve(output);\n    });\n  })\n}\n\nexport default async function main(): Promise<any> {\n  const mainParser = new ArgumentParser();\n  \n  const subparsers = mainParser.add_subparsers({ title: 'commands', dest: 'command' });\n  \n  const clusterCommand = new ClusterCommand();\n  const nonceCommand = new NonceCommand();\n  \n  clusterCommand.setArguments(subparsers.add_parser(clusterCommand.name, { add_help: true }));\n  nonceCommand.setArguments(subparsers.add_parser(nonceCommand.name, { add_help: true }));\n  \n  const messageText = `SSV Scanner v${pkg.version}`;\n  const message = await FigletMessage(messageText);\n  if (message) {\n    console.log(' -----------------------------------------------------------------------------------');\n    console.log(`${message || messageText}`);\n    console.log(' -----------------------------------------------------------------------------------');\n    for (const str of String(pkg.description).match(/.{1,77}/g) || []) {\n      console.log(` ${str}`);\n    }\n    console.log(' -----------------------------------------------------------------------------------\\n');\n  }\n\n  const args = mainParser.parse_args();\n  \n  switch (args.command) {\n    case clusterCommand.name:\n      await clusterCommand.run(args);\n      break;\n    case nonceCommand.name:\n      await nonceCommand.run(args);\n      break;\n    default:\n      console.error('Command not found');\n      process.exit(1);\n  }\n  /*\n  const parser = new ArgumentParser();\n\n  parser.add_argument('-n', '--node-url', {\n    help: `The ETH1 node url.`,\n    required: true,\n    dest: 'nodeUrl'\n  });\n  parser.add_argument('-ca', '--ssv-contract-address', {\n    help:\n      'The SSV Contract address, used to find the latest cluster data snapshot. ' +\n      'Refer to https://docs.ssv.network/developers/smart-contracts',\n    required: true,\n    dest: 'contractAddress'\n  });\n  parser.add_argument('-oa', '--owner-address', {\n    help: \"The owner address regarding the cluster that you want to query\",\n    required: true,\n    dest: 'ownerAddress'\n  });\n  parser.add_argument('-oids', '--operator-ids', {\n    help: `Comma-separated list of operators IDs regarding the cluster that you want to query`,\n    required: true,\n    dest: 'operatorIds'\n  });\n  */\n\n\n  /*\n  try {\n    let params = parser.parse_args();\n    const operatorIds = params.operatorIds.split(',')\n      .map((value: any) => {\n        if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n        return +value;\n      })\n      .sort((a: number, b: number) => a - b);\n\n    const command = new SSVScannerCommand(params);\n    const result = await command.cluster(operatorIds, true);\n    console.table(result.payload);\n    console.log('Cluster snapshot:');\n    console.table(result.cluster);\n    console.log(JSON.stringify({\n      'block': result.payload.Block,\n      'cluster snapshot': result.cluster,\n      'cluster': Object.values(result.cluster)\n    }, null, '  '));\n  } catch (e: any) {\n    console.error('\\x1b[31m', e.message);\n  }\n  */\n}\n", "import { ArgumentParser } from 'argparse';\n\nexport abstract class Command {\n  protected parser: ArgumentParser;\n\n  constructor(public name: string, protected description: string) {\n    this.parser = new ArgumentParser({ description: this.description });\n    this.setArguments(this.parser);\n  }\n\n  abstract setArguments(parser: ArgumentParser): void;\n\n  parse(args: string[]) {\n    return this.parser.parse_args(args);\n  }\n\n  abstract run(args: any): void;\n}", "\nimport cliProgress from 'cli-progress';\nimport Web3Provider from '../web3.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport class NonceScanner extends BaseScanner {\n  protected eventsList = [\n    'ValidatorAdded',\n  ];\n\n  async run(cli?: boolean): Promise<number> {\n    if (cli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);  \n    }\n    try {\n      const data = await this._getLatestNonce(cli);\n      cli && this.progressBar.stop();\n      return data;\n    } catch (e: any) {\n      cli && this.progressBar.stop();\n      throw new Error(e);\n    }\n  }\n\n  private async _getLatestNonce(cli?: boolean): Promise<number> {\n    let latestBlockNumber;\n    try {\n      latestBlockNumber = await Web3Provider.web3(this.params.nodeUrl).eth.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint.');\n    }\n    try {\n      await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).methods.owner().call();\n    } catch (err) {\n      throw new Error('Could not find any cluster snapshot from the provided contract address.');\n    }\n    let step = this.MONTH;\n    let latestNonce = 0;\n\n    const genesisBlock = await Web3Provider.getGenesisBlock(this.params.nodeUrl, this.params.contractAddress);\n    const ownerTopic = Web3Provider.web3().eth.abi.encodeParameter('address', this.params.ownerAddress);\n    const filters = {\n      fromBlock: genesisBlock,\n      toBlock: latestBlockNumber,\n      topics: [null, ownerTopic],\n    };\n\n    cli && this.progressBar.start(latestBlockNumber, 0);\n    do {\n      let result: any;\n      try {\n        result = \n          (await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).getPastEvents('AllEvents', filters))\n          .filter((item: any) => this.eventsList.includes(item.event));\n        latestNonce += result.length;\n        filters.fromBlock = filters.toBlock + 1;\n      } catch (e: any) {\n        if (step === this.MONTH) {\n          step = this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n        } else {\n          throw new Error(e);\n        }\n      }\n      filters.toBlock = Math.min(filters.fromBlock + step, latestBlockNumber);\n      cli && this.progressBar.update(filters.toBlock);\n    } while (filters.toBlock - filters.fromBlock > 0);\n\n    cli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n\n    return latestNonce;\n  }\n}\n", "import Web3 from 'web3';\nimport ABI_V3 from '../shared/v3.abi.json';\n\nexport default class Web3Provider {\n  static BLOCK_RANGE_500K = 500000;\n\n  static web3(nodeUrl: string = '') {\n    return new Web3(nodeUrl);\n  }\n\n  static get abi() {\n    return ABI_V3 as any;\n  }\n\n  static contract(nodeUrl: string, contractAddress: string) {\n    return new (Web3Provider.web3(nodeUrl)).eth.Contract(\n      Web3Provider.abi,\n      contractAddress,\n    );\n  }\n\n  static async getGenesisBlock(nodeUrl: string, contractAddress: string) {\n    const [ fistEvent ] = await Web3Provider.contract(nodeUrl, contractAddress).getPastEvents('Initialized', { fromBlock: 0 });\n    return fistEvent?.blockNumber || 0;\n  }\n}\n", "import Web3Provider from './web3.provider';\n\nexport interface SSVScannerParams {\n  nodeUrl: string,\n  ownerAddress: string,\n  contractAddress: string,\n}\n\nexport abstract class BaseScanner {\n  protected DAY = 5400;\n  protected WEEK = this.DAY * 7;\n  protected MONTH = this.DAY * 30;\n  protected progressBar: any;\n\n  protected params: SSVScannerParams;\n\n  constructor(scannerParams: SSVScannerParams) {\n    if (!scannerParams.contractAddress) {\n      throw Error('Contract address is required');\n    }\n    if (!scannerParams.nodeUrl) {\n      throw Error('ETH1 node is required');\n    }\n    if (!scannerParams.ownerAddress) {\n      throw Error('Cluster owner address is required');\n    }\n    if (scannerParams.contractAddress.length !== 42) {\n      throw Error('Invalid contract address length.');\n    }\n    if (!scannerParams.contractAddress.startsWith('0x')) {\n      throw Error('Invalid contract address.');\n    }\n    if (scannerParams.ownerAddress.length !== 42) {\n      throw Error('Invalid owner address length.');\n    }\n    if (!scannerParams.ownerAddress.startsWith('0x')) {\n      throw Error('Invalid owner address.');\n    }\n    this.params = scannerParams;\n    // convert to checksum addresses\n    this.params.contractAddress = Web3Provider.web3().utils.toChecksumAddress(this.params.contractAddress);\n    this.params.ownerAddress = Web3Provider.web3().utils.toChecksumAddress(this.params.ownerAddress);\n  }\n}", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { NonceScanner } from '../lib/NonceScanner/NonceScanner';\n\nexport class NonceCommand extends Command {\n  constructor() {\n    super('nonce', 'Handles nonce operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url.`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-ca', '--ssv-contract-address', {\n      help:\n        'The SSV network contract address. ' +\n        'Refer to https://docs.ssv.network/developers/smart-contracts',\n      required: true,\n      dest: 'contractAddress'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const nonceScanner = new NonceScanner(args);\n      const result = await nonceScanner.run(true);\n      console.log('Next Nonce:', result);\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}", "import cliProgress from 'cli-progress';\nimport Web3Provider from '../web3.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport interface IData {\n  payload: any;\n  cluster: any;\n}\n\nexport class ClusterScanner extends BaseScanner {\n  protected eventsList = [\n    'ClusterDeposited',\n    'ClusterWithdrawn',\n    'ValidatorRemoved',\n    'ValidatorAdded',\n    'ClusterLiquidated',\n    'ClusterReactivated',\n  ]\n\n  async run(operatorIds: number[], cli?: boolean): Promise<IData> {\n    const validOperatorIds = Array.isArray(operatorIds) && this._isValidOperatorIds(operatorIds.length);\n    if (!validOperatorIds) {\n      throw Error('Comma-separated list of operator IDs. The amount must be 3f+1 compatible.');\n    }\n\n    operatorIds = [...operatorIds].sort((a: number, b: number) => a - b);\n\n    if (cli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);  \n    }\n    const data: IData = await this._getClusterSnapshot(operatorIds, cli);\n    cli && this.progressBar.stop();\n    return data;\n  }\n\n  private async _getClusterSnapshot(operatorIds: number[], cli?: boolean): Promise<IData> {\n    let latestBlockNumber;\n    try {\n      latestBlockNumber = await Web3Provider.web3(this.params.nodeUrl).eth.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint.');\n    }\n    try {\n      await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).methods.owner().call();\n      // HERE we can validate the contract owner address\n    } catch (err) {\n      console.log(\"eee\", err);\n      throw new Error('Could not find any cluster snapshot from the provided contract address.');\n    }\n    let step = this.MONTH;\n    let clusterSnapshot;\n    let biggestBlockNumber = 0;\n\n    const genesisBlock = await Web3Provider.getGenesisBlock(this.params.nodeUrl, this.params.contractAddress);\n    const ownerTopic = Web3Provider.web3().eth.abi.encodeParameter('address', this.params.ownerAddress);\n    const filters = {\n      fromBlock: Math.max(latestBlockNumber - step, genesisBlock),\n      toBlock: latestBlockNumber,\n      topics: [null, ownerTopic],\n    };\n\n    cli && this.progressBar.start(latestBlockNumber, 0);\n    while (!clusterSnapshot && filters.fromBlock >= genesisBlock) {\n      let result: any;\n      try {\n        result = await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).getPastEvents('allEvents', filters);\n        result\n          .filter((item: any) => this.eventsList.includes(item.event))\n          .filter((item: any) => JSON.stringify(item.returnValues.operatorIds.map((value: any) => +value)) === JSON.stringify(operatorIds))\n          .forEach((item: any) => {\n            if (item.blockNumber > biggestBlockNumber) {\n              biggestBlockNumber = item.blockNumber;\n              clusterSnapshot = item.returnValues.cluster;\n            }\n          });\n        filters.toBlock = filters.fromBlock;\n      } catch (e) {\n        console.error(e);\n        if (step === this.MONTH) {\n          step = this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n        }\n      }\n      filters.fromBlock = filters.toBlock - step;\n      cli && this.progressBar.update(latestBlockNumber - (filters.toBlock - step));\n    }\n    cli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n\n    clusterSnapshot = clusterSnapshot || ['0', '0', '0', true, '0'];\n    return {\n      payload: {\n        'Owner': this.params.ownerAddress,\n        'Operators': operatorIds.sort((a: number, b: number) => a - b).join(','),\n        'Block': biggestBlockNumber || latestBlockNumber,\n        'Data': clusterSnapshot.join(','),\n      },\n      cluster: {\n        validatorCount: clusterSnapshot[0],\n        networkFeeIndex: clusterSnapshot[1],\n        index: clusterSnapshot[2],\n        active: clusterSnapshot[3],\n        balance: clusterSnapshot[4],\n      }\n    };\n  }\n\n  private _isValidOperatorIds(operatorsLength: number) {\n    return (operatorsLength < 4 || operatorsLength > 13 || operatorsLength % 3 != 1) ? false : true;\n  }\n}\n", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { ClusterScanner } from '../lib/ClusterScanner/ClusterScanner';\n\nexport class ClusterCommand extends Command {\n  constructor() {\n    super('cluster', 'Handles cluster operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url.`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-ca', '--ssv-contract-address', {\n      help:\n        'The SSV network contract address. ' +\n        'Refer to https://docs.ssv.network/developers/smart-contracts',\n      required: true,\n      dest: 'contractAddress'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n    parser.add_argument('-oids', '--operator-ids', {\n      help: `Comma-separated list of operators IDs regarding the cluster that you want to query`,\n      required: true,\n      dest: 'operatorIds'\n    });  \n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const operatorIds = args.operatorIds.split(',')\n        .map((value: any) => {\n          if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n          return +value;\n        })\n        .sort((a: number, b: number) => a - b);\n      const clusterScanner = new ClusterScanner(args);\n      const result = await clusterScanner.run(operatorIds, true);\n      console.table(result.payload);\n      console.log('Cluster snapshot:');\n      console.table(result.cluster);\n      console.log(JSON.stringify({\n        'block': result.payload.Block,\n        'cluster snapshot': result.cluster,\n        'cluster': Object.values(result.cluster)\n      }, null, '  '));\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}", "#!/usr/bin/env node\n'use strict';\nimport main from './cli-shared';\n\nvoid main();\n"],
  "mappings": ";48BAAA,IAAAA,EAAmB,ooCAEnB,IAAAC,EAA+B,cCF/B,IAAAC,EAA+B,cAETC,EAAf,KAAuB,CAG5B,YAAmBC,EAAwBC,EAAqB,CAA7C,UAAAD,EAAwB,iBAAAC,EACzC,KAAK,OAAS,IAAI,iBAAe,CAAE,YAAa,KAAK,WAAY,CAAC,EAClE,KAAK,aAAa,KAAK,MAAM,CAC/B,CAIA,MAAMC,EAAgB,CACpB,OAAO,KAAK,OAAO,WAAWA,CAAI,CACpC,CAGF,EChBA,IAAAC,EAAwB,qBCDxB,IAAAC,EAAiB,kxkBAGjB,IAAqBC,EAArB,KAAkC,CAGhC,OAAO,KAAKC,EAAkB,GAAI,CAChC,OAAO,IAAI,EAAAC,QAAKD,CAAO,CACzB,CAEA,WAAW,KAAM,CACf,OAAOE,CACT,CAEA,OAAO,SAASF,EAAiBG,EAAyB,CACxD,OAAO,IAAKJ,EAAa,KAAKC,CAAO,GAAG,IAAI,SAC1CD,EAAa,IACbI,CACF,CACF,CAEA,OAAa,gBAAgBH,EAAiBG,EAAyB,QAAAC,EAAA,sBACrE,GAAM,CAAEC,CAAU,EAAI,MAAMN,EAAa,SAASC,EAASG,CAAe,EAAE,cAAc,cAAe,CAAE,UAAW,CAAE,CAAC,EACzH,OAAOE,GAAA,YAAAA,EAAW,cAAe,CACnC,GACF,EAtBqBC,EAArBP,EAAqBO,EACZ,iBAAmB,ICIrB,IAAeC,EAAf,KAA2B,CAQhC,YAAYC,EAAiC,CAP7C,KAAU,IAAM,KAChB,KAAU,KAAO,KAAK,IAAM,EAC5B,KAAU,MAAQ,KAAK,IAAM,GAM3B,GAAI,CAACA,EAAc,gBACjB,MAAM,MAAM,8BAA8B,EAE5C,GAAI,CAACA,EAAc,QACjB,MAAM,MAAM,uBAAuB,EAErC,GAAI,CAACA,EAAc,aACjB,MAAM,MAAM,mCAAmC,EAEjD,GAAIA,EAAc,gBAAgB,SAAW,GAC3C,MAAM,MAAM,kCAAkC,EAEhD,GAAI,CAACA,EAAc,gBAAgB,WAAW,IAAI,EAChD,MAAM,MAAM,2BAA2B,EAEzC,GAAIA,EAAc,aAAa,SAAW,GACxC,MAAM,MAAM,+BAA+B,EAE7C,GAAI,CAACA,EAAc,aAAa,WAAW,IAAI,EAC7C,MAAM,MAAM,wBAAwB,EAEtC,KAAK,OAASA,EAEd,KAAK,OAAO,gBAAkBC,EAAa,KAAK,EAAE,MAAM,kBAAkB,KAAK,OAAO,eAAe,EACrG,KAAK,OAAO,aAAeA,EAAa,KAAK,EAAE,MAAM,kBAAkB,KAAK,OAAO,YAAY,CACjG,CACF,EFrCO,IAAMC,EAAN,cAA2BC,CAAY,CAAvC,kCACL,KAAU,WAAa,CACrB,gBACF,EAEM,IAAIC,EAAgC,QAAAC,EAAA,sBACpCD,IACF,QAAQ,IAAI;AAAA,uBAA0B,EACtC,KAAK,YAAc,IAAI,EAAAE,QAAY,UAAU,CAAC,EAAG,EAAAA,QAAY,QAAQ,cAAc,GAErF,GAAI,CACF,IAAMC,EAAO,MAAM,KAAK,gBAAgBH,CAAG,EAC3C,OAAAA,GAAO,KAAK,YAAY,KAAK,EACtBG,CACT,OAASC,EAAP,CACA,MAAAJ,GAAO,KAAK,YAAY,KAAK,EACvB,IAAI,MAAMI,CAAC,CACnB,CACF,GAEc,gBAAgBJ,EAAgC,QAAAC,EAAA,sBAC5D,IAAII,EACJ,GAAI,CACFA,EAAoB,MAAMC,EAAa,KAAK,KAAK,OAAO,OAAO,EAAE,IAAI,eAAe,CACtF,OAASC,EAAP,CACA,MAAM,IAAI,MAAM,8CAA8C,CAChE,CACA,GAAI,CACF,MAAMD,EAAa,SAAS,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAAE,QAAQ,MAAM,EAAE,KAAK,CACrG,OAASC,EAAP,CACA,MAAM,IAAI,MAAM,yEAAyE,CAC3F,CACA,IAAIC,EAAO,KAAK,MACZC,EAAc,EAEZC,EAAe,MAAMJ,EAAa,gBAAgB,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAClGK,EAAaL,EAAa,KAAK,EAAE,IAAI,IAAI,gBAAgB,UAAW,KAAK,OAAO,YAAY,EAC5FM,EAAU,CACd,UAAWF,EACX,QAASL,EACT,OAAQ,CAAC,KAAMM,CAAU,CAC3B,EAEAX,GAAO,KAAK,YAAY,MAAMK,EAAmB,CAAC,EAClD,EAAG,CACD,IAAIQ,EACJ,GAAI,CACFA,GACG,MAAMP,EAAa,SAAS,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAAE,cAAc,YAAaM,CAAO,GAChH,OAAQE,GAAc,KAAK,WAAW,SAASA,EAAK,KAAK,CAAC,EAC7DL,GAAeI,EAAO,OACtBD,EAAQ,UAAYA,EAAQ,QAAU,CACxC,OAASR,EAAP,CACA,GAAII,IAAS,KAAK,MAChBA,EAAO,KAAK,aACHA,IAAS,KAAK,KACvBA,EAAO,KAAK,QAEZ,OAAM,IAAI,MAAMJ,CAAC,CAErB,CACAQ,EAAQ,QAAU,KAAK,IAAIA,EAAQ,UAAYJ,EAAMH,CAAiB,EACtEL,GAAO,KAAK,YAAY,OAAOY,EAAQ,OAAO,CAChD,OAASA,EAAQ,QAAUA,EAAQ,UAAY,GAE/C,OAAAZ,GAAO,KAAK,YAAY,OAAOK,EAAmBA,CAAiB,EAE5DI,CACT,GACF,EGvEO,IAAMM,EAAN,cAA2BC,CAAQ,CACxC,aAAc,CACZ,MAAM,QAAS,0BAA0B,CAC3C,CAEA,aAAaC,EAA8B,CACzCA,EAAO,aAAa,KAAM,aAAc,CACtC,KAAM,6CACN,SAAU,GACV,KAAM,SACR,CAAC,EACDA,EAAO,aAAa,MAAO,yBAA0B,CACnD,KACE,iGAEF,SAAU,GACV,KAAM,iBACR,CAAC,EACDA,EAAO,aAAa,MAAO,kBAAmB,CAC5C,KAAM,kDACN,SAAU,GACV,KAAM,cACR,CAAC,CACH,CAEM,IAAIC,EAA0B,QAAAC,EAAA,sBAClC,GAAI,CAEF,IAAMC,EAAS,MADM,IAAIC,EAAaH,CAAI,EACR,IAAI,EAAI,EAC1C,QAAQ,IAAI,cAAeE,CAAM,CACnC,OAAS,EAAP,CACA,QAAQ,MAAM,WAAY,EAAE,OAAO,CACrC,CACF,GACF,ECtCA,IAAAE,EAAwB,qBAUjB,IAAMC,EAAN,cAA6BC,CAAY,CAAzC,kCACL,KAAU,WAAa,CACrB,mBACA,mBACA,mBACA,iBACA,oBACA,oBACF,EAEM,IAAIC,EAAuBC,EAA+B,QAAAC,EAAA,sBAE9D,GAAI,EADqB,MAAM,QAAQF,CAAW,GAAK,KAAK,oBAAoBA,EAAY,MAAM,GAEhG,MAAM,MAAM,2EAA2E,EAGzFA,EAAc,CAAC,GAAGA,CAAW,EAAE,KAAK,CAACG,EAAWC,IAAcD,EAAIC,CAAC,EAE/DH,IACF,QAAQ,IAAI;AAAA,uBAA0B,EACtC,KAAK,YAAc,IAAI,EAAAI,QAAY,UAAU,CAAC,EAAG,EAAAA,QAAY,QAAQ,cAAc,GAErF,IAAMC,EAAc,MAAM,KAAK,oBAAoBN,EAAaC,CAAG,EACnE,OAAAA,GAAO,KAAK,YAAY,KAAK,EACtBK,CACT,GAEc,oBAAoBN,EAAuBC,EAA+B,QAAAC,EAAA,sBACtF,IAAIK,EACJ,GAAI,CACFA,EAAoB,MAAMC,EAAa,KAAK,KAAK,OAAO,OAAO,EAAE,IAAI,eAAe,CACtF,OAASC,EAAP,CACA,MAAM,IAAI,MAAM,8CAA8C,CAChE,CACA,GAAI,CACF,MAAMD,EAAa,SAAS,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAAE,QAAQ,MAAM,EAAE,KAAK,CAErG,OAASC,EAAP,CACA,cAAQ,IAAI,MAAOA,CAAG,EAChB,IAAI,MAAM,yEAAyE,CAC3F,CACA,IAAIC,EAAO,KAAK,MACZC,EACAC,EAAqB,EAEnBC,EAAe,MAAML,EAAa,gBAAgB,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAClGM,EAAaN,EAAa,KAAK,EAAE,IAAI,IAAI,gBAAgB,UAAW,KAAK,OAAO,YAAY,EAC5FO,EAAU,CACd,UAAW,KAAK,IAAIR,EAAoBG,EAAMG,CAAY,EAC1D,QAASN,EACT,OAAQ,CAAC,KAAMO,CAAU,CAC3B,EAGA,IADAb,GAAO,KAAK,YAAY,MAAMM,EAAmB,CAAC,EAC3C,CAACI,GAAmBI,EAAQ,WAAaF,GAAc,CAC5D,IAAIG,EACJ,GAAI,CACFA,EAAS,MAAMR,EAAa,SAAS,KAAK,OAAO,QAAS,KAAK,OAAO,eAAe,EAAE,cAAc,YAAaO,CAAO,EACzHC,EACG,OAAQC,GAAc,KAAK,WAAW,SAASA,EAAK,KAAK,CAAC,EAC1D,OAAQA,GAAc,KAAK,UAAUA,EAAK,aAAa,YAAY,IAAKC,GAAe,CAACA,CAAK,CAAC,IAAM,KAAK,UAAUlB,CAAW,CAAC,EAC/H,QAASiB,GAAc,CAClBA,EAAK,YAAcL,IACrBA,EAAqBK,EAAK,YAC1BN,EAAkBM,EAAK,aAAa,QAExC,CAAC,EACHF,EAAQ,QAAUA,EAAQ,SAC5B,OAASI,EAAP,CACA,QAAQ,MAAMA,CAAC,EACXT,IAAS,KAAK,MAChBA,EAAO,KAAK,KACHA,IAAS,KAAK,OACvBA,EAAO,KAAK,IAEhB,CACAK,EAAQ,UAAYA,EAAQ,QAAUL,EACtCT,GAAO,KAAK,YAAY,OAAOM,GAAqBQ,EAAQ,QAAUL,EAAK,CAC7E,CACA,OAAAT,GAAO,KAAK,YAAY,OAAOM,EAAmBA,CAAiB,EAEnEI,EAAkBA,GAAmB,CAAC,IAAK,IAAK,IAAK,GAAM,GAAG,EACvD,CACL,QAAS,CACP,MAAS,KAAK,OAAO,aACrB,UAAaX,EAAY,KAAK,CAACG,EAAWC,IAAcD,EAAIC,CAAC,EAAE,KAAK,GAAG,EACvE,MAASQ,GAAsBL,EAC/B,KAAQI,EAAgB,KAAK,GAAG,CAClC,EACA,QAAS,CACP,eAAgBA,EAAgB,GAChC,gBAAiBA,EAAgB,GACjC,MAAOA,EAAgB,GACvB,OAAQA,EAAgB,GACxB,QAASA,EAAgB,EAC3B,CACF,CACF,GAEQ,oBAAoBS,EAAyB,CACnD,MAAQ,EAAAA,EAAkB,GAAKA,EAAkB,IAAMA,EAAkB,GAAK,EAChF,CACF,EC5GO,IAAMC,EAAN,cAA6BC,CAAQ,CAC1C,aAAc,CACZ,MAAM,UAAW,4BAA4B,CAC/C,CAEA,aAAaC,EAA8B,CACzCA,EAAO,aAAa,KAAM,aAAc,CACtC,KAAM,6CACN,SAAU,GACV,KAAM,SACR,CAAC,EACDA,EAAO,aAAa,MAAO,yBAA0B,CACnD,KACE,iGAEF,SAAU,GACV,KAAM,iBACR,CAAC,EACDA,EAAO,aAAa,MAAO,kBAAmB,CAC5C,KAAM,kDACN,SAAU,GACV,KAAM,cACR,CAAC,EACDA,EAAO,aAAa,QAAS,iBAAkB,CAC7C,KAAM,qFACN,SAAU,GACV,KAAM,aACR,CAAC,CACH,CAEM,IAAIC,EAA0B,QAAAC,EAAA,sBAClC,GAAI,CACF,IAAMC,EAAcF,EAAK,YAAY,MAAM,GAAG,EAC3C,IAAKG,GAAe,CACnB,GAAI,OAAO,MAAM,CAACA,CAAK,EAAG,MAAM,IAAI,MAAM,kCAAkC,EAC5E,MAAO,CAACA,CACV,CAAC,EACA,KAAK,CAACC,EAAWC,IAAcD,EAAIC,CAAC,EAEjCC,EAAS,MADQ,IAAIC,EAAeP,CAAI,EACV,IAAIE,EAAa,EAAI,EACzD,QAAQ,MAAMI,EAAO,OAAO,EAC5B,QAAQ,IAAI,mBAAmB,EAC/B,QAAQ,MAAMA,EAAO,OAAO,EAC5B,QAAQ,IAAI,KAAK,UAAU,CACzB,MAASA,EAAO,QAAQ,MACxB,mBAAoBA,EAAO,QAC3B,QAAW,OAAO,OAAOA,EAAO,OAAO,CACzC,EAAG,KAAM,IAAI,CAAC,CAChB,OAAS,EAAP,CACA,QAAQ,MAAM,WAAY,EAAE,OAAO,CACrC,CACF,GACF,EPhDA,IAAME,EAAuBC,GAAoBC,EAAA,wBAC/C,OAAO,IAAI,QAAQC,GAAW,IAC5B,EAAAC,SAAOH,EAAS,CAACI,EAAYC,IAAoB,CAC/C,GAAID,EACF,OAAOF,EAAQ,EAAE,EAEnBA,EAAQG,CAAM,CAChB,CAAC,CACH,CAAC,CACH,GAEA,SAAOC,GAA4C,QAAAL,EAAA,sBACjD,IAAMM,EAAa,IAAI,iBAEjBC,EAAaD,EAAW,eAAe,CAAE,MAAO,WAAY,KAAM,SAAU,CAAC,EAE7EE,EAAiB,IAAIC,EACrBC,EAAe,IAAIC,EAEzBH,EAAe,aAAaD,EAAW,WAAWC,EAAe,KAAM,CAAE,SAAU,EAAK,CAAC,CAAC,EAC1FE,EAAa,aAAaH,EAAW,WAAWG,EAAa,KAAM,CAAE,SAAU,EAAK,CAAC,CAAC,EAEtF,IAAME,EAAc,gBAAgBC,EAAI,UAClCd,EAAU,MAAMD,EAAcc,CAAW,EAC/C,GAAIb,EAAS,CACX,QAAQ,IAAI,sFAAsF,EAClG,QAAQ,IAAI,GAAGA,GAAWa,GAAa,EACvC,QAAQ,IAAI,sFAAsF,EAClG,QAAWE,KAAO,OAAOD,EAAI,WAAW,EAAE,MAAM,UAAU,GAAK,CAAC,EAC9D,QAAQ,IAAI,IAAIC,GAAK,EAEvB,QAAQ,IAAI;AAAA,CAAwF,CACtG,CAEA,IAAMC,EAAOT,EAAW,WAAW,EAEnC,OAAQS,EAAK,cACNP,EAAe,KAClB,MAAMA,EAAe,IAAIO,CAAI,EAC7B,WACGL,EAAa,KAChB,MAAMA,EAAa,IAAIK,CAAI,EAC3B,cAEA,QAAQ,MAAM,mBAAmB,EACjC,QAAQ,KAAK,CAAC,EAsDpB,GQvGKC,EAAK",
  "names": ["import_figlet", "import_argparse", "import_argparse", "Command", "name", "description", "args", "import_cli_progress", "import_web3", "_Web3Provider", "nodeUrl", "Web3", "v3_abi_default", "contractAddress", "__async", "fistEvent", "Web3Provider", "BaseScanner", "scannerParams", "Web3Provider", "NonceScanner", "BaseScanner", "cli", "__async", "cliProgress", "data", "e", "latestBlockNumber", "Web3Provider", "err", "step", "latestNonce", "genesisBlock", "ownerTopic", "filters", "result", "item", "NonceCommand", "Command", "parser", "args", "__async", "result", "NonceScanner", "import_cli_progress", "ClusterScanner", "BaseScanner", "operatorIds", "cli", "__async", "a", "b", "cliProgress", "data", "latestBlockNumber", "Web3Provider", "err", "step", "clusterSnapshot", "biggestBlockNumber", "genesisBlock", "ownerTopic", "filters", "result", "item", "value", "e", "operatorsLength", "ClusterCommand", "Command", "parser", "args", "__async", "operatorIds", "value", "a", "b", "result", "ClusterScanner", "FigletMessage", "message", "__async", "resolve", "figlet", "error", "output", "main", "mainParser", "subparsers", "clusterCommand", "ClusterCommand", "nonceCommand", "NonceCommand", "messageText", "package_default", "str", "args", "main"]
}
